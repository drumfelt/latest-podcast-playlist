const sqlite3 = require('sqlite3').verbose();
const config = require('config');
const dbPath = config.get('dbPath');
const client_id = config.get('clientId');
const client_secret = config.get('clientSecret');
const request = require('request');
const queryString = require('querystring');
const _ = require('lodash');
const moment = require('moment');

const db = new sqlite3.Database(dbPath, sqlite3.OPEN_READWRITE, (err) => {
    if (err) {
        console.error('Failed to connect to database. Error: ', err.message);
        return;
    }
    console.log('Connected to the database.');

    startPlaylistCreation().then((playlist) => {
        console.log('playlist id', playlist.id);
        db.run('insert into created_playlists(playlist_id, date_added) values(?, ?);',
            playlist.id, moment().format());

        const createdPlaylists = [];
        db.each('select playlist_id, date_added from created_playlists', (err, row) => {
            createdPlaylists.push(row);
        });

        const opts = {
            url: `https://api.spotify.com/v1/playlists/${createdPlaylists[0].playlist_id}/followers`,
            json: true,
            headers: {
                'Authorization': 'Bearer ' + authTokens.access,
                'Content-Type': 'application/json'
            }
        };
        
        request.delete(opts, (error, response, body) => {
            console.log(response.statusCode, body);
        });

        db.close(() => {
            console.log('Database connection closed.');
        });
    });
});

let authTokens = {};
let userData = {};

async function startPlaylistCreation() {
    console.log('Begining playlist creation ...');
    await getTokenFromDb();

    // token may be expired. refresh token if first attempt fails.
    try {
        await getUserData();
    } catch (error) {
        await refreshToken();
        await getUserData();
    }

    const shows = await getFollowedPodcasts();
    return await createPlaylist(shows);
}

async function createPlaylist(shows) {
    if (shows && shows.items && !_.isEmpty(shows.items)) {
        const playlist = await createEmptyPlaylist();
        const episodes = await getLatestEpisodes(shows);
        await addItemsToPlaylist(playlist, episodes);
        return playlist;
    } else {
        console.log('No shows.');
    }
}

async function getLatestEpisodes(shows) {
    console.log('Getting latest podcast episodes ...');
    const episodes = [];
    await Promise.all(shows.items.map(async (item) => {
        try {
            await checkIfShowIsAudioBook(item.show.id);
            const episode = await getEpisode(item.show.id);
            episodes.push(episode);
        } catch (error) {
            console.log(`Error getting episode. show: ${item.show.id}. Error: `, error);
        }
    }));

    episodes.sort((a, b) => {
        return a.items[0].duration_ms - b.items[0].duration_ms;
    });

    return episodes;
}

function checkIfShowIsAudioBook(showId) {
    return new Promise((resolve, reject) => {
        const options = {
            url: `https://api.spotify.com/v1/audiobooks/${showId}`,
            json: true,
            headers: {
                'Authorization': 'Bearer ' + authTokens.access,
                'Content-Type': 'application/json'
            },
        };
        request.get(options, (error, response, body) => {
            if (response.statusCode === 200) {
                reject('This is an audio book.');
            } else {
                resolve();
            }
        });
    });
}

function createEmptyPlaylist() {
    return new Promise((resolve, reject) => {
        console.log('Creating empty playlist');
        const data = JSON.stringify({
            name: `${new Date().toLocaleDateString("en-US")} - latest podcast episodes`,
            description: 'generated by an application'
        });
        const playListOptions = {
            url: `https://api.spotify.com/v1/users/${userData.id}/playlists`,
            json: true,
            headers: {
                'Authorization': 'Bearer ' + authTokens.access,
                'Content-Type': 'application/json'
            },
            form: data

        };
        request.post(playListOptions, (error, response, playlist) => {
            if (response.statusCode === 201) {
                resolve(playlist);
            } else {
                reject(response);
            }
        });
    });
}

function getEpisode(showId) {
    return new Promise((resolve, reject) => {
        const options = {
            url: `https://api.spotify.com/v1/shows/${showId}/episodes?${queryString.stringify({
                offset: 0,
                limit: 1
            })}`,
            headers: {
                'Authorization': 'Bearer ' + authTokens.access,
                'Content-Type': 'application/json'
            },
            json: true
        };

        request.get(options, (error, response, episode) => {
            resolve(episode);
        });
    });
}

function addItemsToPlaylist(playList, episodes) {
    console.log('Adding podcast episodes to playlist ...');
    return new Promise((resolve, reject) => {
        const uris = [];
        episodes.filter((episode) => {
            return !episode.items[0].resume_point.fully_played;
        }).forEach((episode) => {
            uris.push(episode.items[0].uri);
        });
        const data = JSON.stringify({
            uris: uris
        });
        const addToPlaylistOptions = {
            url: playList.tracks.href,
            form: data,
            headers: {
                'Authorization': 'Bearer ' + authTokens.access,
                'Content-Type': 'application/json'
            },
            json: true
        };
        request.post(addToPlaylistOptions, (error, response, body) => {
            if (response.statusCode === 201) {
                console.log('Episodes added to playlist');
            } else {
                console.log('Episodes not added to playlist')
            }
            resolve();
        })
    });
}

function getTokenFromDb() {
    console.log('Getting auth token ...');
    return new Promise((resolve, reject) => {
        db.get('select * from tokens', (err, row) => {
            if (err) {
                console.log('Error getting auth token : ', err);
            } else {
                authTokens = row;
                resolve(row);
            }
        })
    });
}

function getFollowedPodcasts() {
    return new Promise((resolve, reject) => {
        console.log('Getting followed podcasts ...');
        const options = {
            url: 'https://api.spotify.com/v1/me/shows',
            headers: {
                'Authorization': 'Bearer ' + authTokens.access,
                'Content-Type': 'application/json'
            },
            json: true
        };

        request.get(options, (error, response, body) => {

            if (body.error && body.error.status === 401) {
                reject();
            } else {
                resolve(body);
            }
        });
    });
}

function refreshToken() {
    console.log('Refreshing auth token ...');
    return new Promise((resolve, reject) => {
        const authOptions = {
            url: 'https://accounts.spotify.com/api/token',
            headers: { 'Authorization': 'Basic ' + (new Buffer(client_id + ':' + client_secret).toString('base64')) },
            form: {
                grant_type: 'refresh_token',
                refresh_token: authTokens.refresh
            },
            json: true
        };

        request.post(authOptions, function (error, response, body) {
            if (!error && response.statusCode === 200) {
                db.run('update tokens set access = ?', body.access_token);
                authTokens.access = body.access_token;
                resolve();
            } else {
                console.log(error);
            }
        });
    });
}

function getUserData() {
    return new Promise((resolve, reject) => {
        console.log('Getting user data ...');
        const options = {
            url: 'https://api.spotify.com/v1/me',
            headers: {
                'Authorization': 'Bearer ' + authTokens.access,
                'Content-Type': 'application/json'
            },
            json: true
        };

        request.get(options, (error, response, body) => {

            if (body.error && body.error.status === 401) {
                reject();
            } else {
                userData = body;
                resolve(body);
            }
        });
    });
}
