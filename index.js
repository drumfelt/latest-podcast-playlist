const sqlite3 = require('sqlite3').verbose();
const config = require('config');
const dbPath = config.get('dbPath');
const client_id = config.get('clientId');
const client_secret = config.get('clientSecret');
const request = require('request');
const queryString = require('querystring');
const _ = require('lodash');

const db = new sqlite3.Database(dbPath, sqlite3.OPEN_READWRITE, (err) => {
    if (err) {
        console.error(Date.now(), err.message);
    }
    console.log('Connected to the database.');

    startPlaylistCreation();
});

let authTokens = {};
let userData = {};

async function startPlaylistCreation() {
    await getTokenFromDb();

    // token may be expired. refresh token if first attempt fails.
    try {
        await getUserData();
    } catch (error) {
        await refreshToken();
        await getUserData();
    }

    const shows = await getFollowedPodcasts();
    await createListOfShowIds(shows);
}

function createListOfShowIds(shows) {
    console.log('createListOfShowIds');
    if (shows && shows.items && !_.isEmpty(shows.items)) {
        const data = JSON.stringify({
            name: `${new Date().toLocaleDateString("en-US")} - latest podcast episodes`,
            description: 'generated by an application'
        });
        const playListOptions = {
            url: `https://api.spotify.com/v1/users/${userData.id}/playlists`,
            json: true,
            headers: {
                'Authorization': 'Bearer ' + authTokens.access,
                'Content-Type': 'application/json'
            },
            form: data

        };
        console.log(playListOptions);
        request.post(playListOptions, (error, response, body) => {
            console.log(response.statusMessage);
            if (response.statusCode === 201) {
                const playlist = body;
                const first = shows.items[0];
                const options = {
                    url: `https://api.spotify.com/v1/shows/${first.show.id}/episodes?${queryString.stringify({
                        offset: 0,
                        limit: 1
                    })}`,
                    headers: {
                        'Authorization': 'Bearer ' + authTokens.access,
                        'Content-Type': 'application/json'
                    },
                    json: true
                };

                request.get(options, (error, response, body) => {
                    console.log('get episodes');
                    // console.log(JSON.stringify(body));
                    const episodeId = body.items[0].id;
                });
            }
        });
    }
}

function getTokenFromDb() {
    console.log('getToken');
    return new Promise((resolve, reject) => {
        db.get('select * from tokens', (err, row) => {
            if (err) {
                console.log(Date.now(), 'error in getToken() : ', err);
            } else {
                authTokens = row;
                resolve(row);
            }
        })
    });
}

function getFollowedPodcasts() {
    return new Promise((resolve, reject) => {
        console.log('getFollowedPodcasts');
        const options = {
            url: 'https://api.spotify.com/v1/me/shows',
            headers: {
                'Authorization': 'Bearer ' + authTokens.access,
                'Content-Type': 'application/json'
            },
            json: true
        };

        request.get(options, (error, response, body) => {

            if (body.error && body.error.status === 401) {
                reject();
            } else {
                resolve(body);
            }
        });
    });
}

function refreshToken() {
    console.log('refreshToken');
    return new Promise((resolve, reject) => {
        const authOptions = {
            url: 'https://accounts.spotify.com/api/token',
            headers: { 'Authorization': 'Basic ' + (new Buffer(client_id + ':' + client_secret).toString('base64')) },
            form: {
                grant_type: 'refresh_token',
                refresh_token: authTokens.refresh
            },
            json: true
        };

        request.post(authOptions, function (error, response, body) {
            if (!error && response.statusCode === 200) {
                db.run('update tokens set access = ?', body.access_token);
                authTokens.access = body.access_token;
                resolve();
            } else {
                console.log(Date.now(), error);
            }
        });
    });
}

function getUserData() {
    return new Promise((resolve, reject) => {
        console.log('getUserData');
        const options = {
            url: 'https://api.spotify.com/v1/me',
            headers: {
                'Authorization': 'Bearer ' + authTokens.access,
                'Content-Type': 'application/json'
            },
            json: true
        };

        request.get(options, (error, response, body) => {

            if (body.error && body.error.status === 401) {
                reject();
            } else {
                userData = body;
                resolve(body);
            }
        });
    });
}
